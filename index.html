<!DOCTYPE html>
<html lang="en">
<head>
  <style>
  body {
    margin: 0;
    font-family: sans-serif;
    background: #1e1e1e;
    color: #eee;
  }

  #app {
    display: grid;
    grid-template-columns: 200px 1fr 200px;
    height: calc(100vh - 60px);
  }

  aside, main {
    padding: 10px;
    border-right: 1px solid #333;
  }

  #eq-panel {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  canvas {
    background: #111;
    border: 1px solid #444;
  }

  footer {
    height: 60px;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    background: #111;
    border-top: 1px solid #333;
  }

  button {
    background: #333;
    color: white;
    border: none;
    padding: 6px 12px;
    cursor: pointer;
  }

  button:hover {
    background: #555;
  }
</style>

  <meta charset="UTF-8" />
  <title>Audio Training For Dummeis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

  <button id="play">Play</button>
  <button id="stop">Stop</button>

  
  <script type="module">
    
const canvas = document.getElementById("eq-canvas");
const ctx = canvas.getContext("2d");

const FREQ_MIN = 20;
const FREQ_MAX = 20000;
const GAIN_MIN = -24;
const GAIN_MAX = 24;

let activeBand = null;
let isDragging = false;

    /* Audio Engine will live here */
// =====================
// Audio Context
// =====================
const audioContext = new (window.AudioContext || window.webkitAudioContext)();

// =====================
// Master Output
// =====================
const masterGain = audioContext.createGain();
masterGain.gain.value = 1;
masterGain.connect(audioContext.destination);

// =====================
// State
// =====================
let sourceNode = null;
let audioBuffer = null;

const eqBands = [];
const preFX = [];
const postFX = [];

// =====================
// Load Audio
// =====================
async function loadAudio(url) {
  const res = await fetch(url);
  const arrayBuffer = await res.arrayBuffer();
  audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
}

// =====================
// Create Source
// =====================
function createSource() {
  if (!audioBuffer) return;

  sourceNode = audioContext.createBufferSource();
  sourceNode.buffer = audioBuffer;
  sourceNode.loop = true;
}

// =====================
// EQ Band Factory
// =====================
function createEQBand({
  type = "peaking",
  frequency = 1000,
  gain = 0,
  Q = 1
} = {}) {
  const node = audioContext.createBiquadFilter();
  node.type = type;
  node.frequency.value = frequency;
  node.gain.value = gain;
  node.Q.value = Q;

  return {
    node,
    type,
    frequency,
    gain,
    Q,
    enabled: true
  };
}

// =====================
// Add / Remove EQ Bands
// =====================
function addEQBand(options) {
  const band = createEQBand(options);
  eqBands.push(band);
  rebuildGraph();
  return band;
}

function removeEQBand(index) {
  if (!eqBands[index]) return;
  eqBands[index].node.disconnect();
  eqBands.splice(index, 1);
  rebuildGraph();
}

// =====================
// Graph Rebuild
// =====================
function rebuildGraph() {
  if (!sourceNode) return;

  // Disconnect everything
  sourceNode.disconnect();
  eqBands.forEach(b => b.node.disconnect());
  preFX.forEach(fx => fx.disconnect?.());
  postFX.forEach(fx => fx.disconnect?.());

  let node = sourceNode;

  // Pre FX
  preFX.forEach(fx => {
    node.connect(fx);
    node = fx;
  });

  // EQ Bands
  eqBands.forEach(band => {
    if (!band.enabled) return;
    node.connect(band.node);
    node = band.node;
  });

  // Post FX
  postFX.forEach(fx => {
    node.connect(fx);
    node = fx;
  });

  node.connect(masterGain);
}

// =====================
// Transport
// =====================
function play() {
  if (audioContext.state === "suspended") {
    audioContext.resume();
  }

  if (sourceNode) {
    sourceNode.stop();
    sourceNode.disconnect();
  }

  createSource();
  rebuildGraph();
  sourceNode.start();
}

function stop() {
  if (!sourceNode) return;
  sourceNode.stop();
  sourceNode.disconnect();
  sourceNode = null;
}

// =====================
// Demo Controls
// =====================
document.getElementById("play").onclick = async () => {
  if (!audioBuffer) {
    await loadAudio("./audio/demo.wav"); // put a file here
    addEQBand({ frequency: 1000, gain: 6 });
    addEQBand({ frequency: 300, gain: -4, Q: 1.2 });
  }
  play();
  
  document.querySelectorAll("[data-audio]").forEach(btn => {
  btn.onclick = async () => {
    await loadAudio(btn.dataset.audio);
    play();
  };
    // =====================
// EQ Math Helpers
// =====================
function freqToX(freq) {
  const minLog = Math.log10(FREQ_MIN);
  const maxLog = Math.log10(FREQ_MAX);
  return (
    (Math.log10(freq) - minLog) /
    (maxLog - minLog)
  ) * canvas.width;
}

function xToFreq(x) {
  const minLog = Math.log10(FREQ_MIN);
  const maxLog = Math.log10(FREQ_MAX);
  return Math.pow(
    10,
    minLog + (x / canvas.width) * (maxLog - minLog)
  );
}

function gainToY(gain) {
  return canvas.height / 2 - (gain / (GAIN_MAX - GAIN_MIN)) * canvas.height;
}

function yToGain(y) {
  return ((canvas.height / 2 - y) / canvas.height) * (GAIN_MAX - GAIN_MIN);
}

// =====================
// EQ Drawing
// =====================
function drawGrid() {
  ctx.strokeStyle = "#333";
  const freqs = [20,50,100,200,500,1000,2000,5000,10000,20000];
  freqs.forEach(f => {
    const x = freqToX(f);
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  });

  ctx.strokeStyle = "#555";
  ctx.beginPath();
  ctx.moveTo(0, canvas.height / 2);
  ctx.lineTo(canvas.width, canvas.height / 2);
  ctx.stroke();
}

function drawBands() {
  eqBands.forEach(band => {
    const x = freqToX(band.node.frequency.value);
    const y = gainToY(band.node.gain.value);

    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fillStyle = "#4fc3f7";
    ctx.fill();
  });
}

function drawEQ() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#111";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  drawGrid();
  drawBands();

  requestAnimationFrame(drawEQ);
}
// =====================
// EQ Interaction
// =====================
function getBandAtPosition(x, y) {
  return eqBands.find(band => {
    const bx = freqToX(band.node.frequency.value);
    const by = gainToY(band.node.gain.value);
    return Math.hypot(bx - x, by - y) < 8;
  });
}

canvas.addEventListener("mousedown", e => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  activeBand = getBandAtPosition(x, y);
  isDragging = !!activeBand;
});

canvas.addEventListener("mousemove", e => {
  if (!isDragging || !activeBand) return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  activeBand.node.frequency.value = Math.min(
    FREQ_MAX,
    Math.max(FREQ_MIN, xToFreq(x))
  );

  activeBand.node.gain.value = Math.min(
    GAIN_MAX,
    Math.max(GAIN_MIN, yToGain(y))
  );
});

canvas.addEventListener("mouseup", () => {
  isDragging = false;
  activeBand = null;
});

canvas.addEventListener("wheel", e => {
  if (!activeBand) return;
  e.preventDefault();

  activeBand.node.Q.value = Math.max(
    0.1,
    Math.min(18, activeBand.node.Q.value + e.deltaY * -0.01)
  );
});
    
addEQBand({ frequency: 1000, gain: 6 });

drawEQ();

});

};

document.getElementById("stop").onclick = stop;

  </script>

<body>
  <div id="app">
    <aside id="audio-list">
      <h3>Audio Files</h3>
      <button data-audio="./audio/demo.wav">Demo Track</button>
    </aside>

    <main id="eq-panel">
      <canvas id="eq-canvas" width="800" height="400"></canvas>
    </main>

    <aside id="fx-rack">
      <h3>FX</h3>
      <p>Coming soon</p>
    </aside>
  </div>

  <footer>
    <button id="play">Play</button>
    <button id="stop">Stop</button>
  </footer>

  <script type="module">
    /* audio engine stays here */
  </script>
</body>
</html>
