<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Audio Training for Dummies</title>
<style>
  body {
    margin: 0;
    font-family: sans-serif;
    background: #111;
    color: #ddd;
  }

  #app {
    display: grid;
    grid-template-columns: 260px 1fr 260px;
    height: 100vh;
  }

  /* TRACK LIST */
  #tracks {
    background: #1a1a1a;
    padding: 10px;
    overflow-y: auto;
  }

  .track {
    padding: 6px;
    border-bottom: 1px solid #333;
    cursor: pointer;
  }

  .track.active {
    background: #2a2a2a;
  }

  .track-controls {
    display: flex;
    align-items: center;
    gap: 4px;
    margin-top: 4px;
  }

  .track-controls button {
    font-size: 10px;
    width: 22px;
    height: 22px;
    background: #333;
    color: #ddd;
    border: none;
    cursor: pointer;
  }

  .track-controls button.muted {
    background: #b00000;
  }

  .track-controls button.soloed {
    background: #b0b000;
    color: #000;
  }

  .track-controls input[type="range"] {
    flex: 1;
  }

  /* EQ PANEL */
  #eq-panel {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px;
  }

  canvas {
    background: #000;
    border: 1px solid #333;
    cursor: crosshair;
  }

  canvas.band-hover {
    cursor: grab;
  }

  canvas.band-dragging {
    cursor: grabbing;
  }

  #controls {
    margin-top: 10px;
    display: flex;
    gap: 10px;
  }

  button {
    background: #333;
    color: #ddd;
    border: none;
    padding: 8px 12px;
    font-size: 16px;
    cursor: pointer;
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* Band type selector container */
  #band-type-container {
    margin-top: 10px;
    color: #ddd;
    font-size: 14px;
  }

  #band-type-select {
    background: #222;
    color: #ddd;
    border: 1px solid #444;
    padding: 4px 6px;
    font-size: 14px;
    margin-left: 6px;
    cursor: pointer;
  }

  /* FX RACK */
  #fx-rack {
    background: #1a1a1a;
    padding: 10px;
    overflow-y: auto;
  }

  #transport {
    margin-bottom: 10px;
  }

  /* Dynamics Panel */
  #dynamics {
    margin-top: 20px;
    border-top: 1px solid #333;
    padding-top: 10px;
    font-size: 13px;
  }

  #dynamics input[type="range"] {
    width: 100%;
  }
</style>
</head>
<body>
<div id="app">

  <!-- TRACKS -->
  <aside id="tracks">
    <div id="transport">
      <button id="load">Load Tracks</button>
      <button id="play" disabled>Play</button>
      <button id="stop" disabled>Stop</button>
    </div>
    <div id="track-list"></div>
  </aside>

  <!-- EQ -->
  <main id="eq-panel">
    <canvas id="eq" width="900" height="400"></canvas>
    <div id="controls">
      <button id="add-band" disabled>Add EQ Band</button>
      <button id="delete-band" disabled>Delete Selected Band</button>
    </div>
    <div id="band-type-container">
      <label for="band-type-select">Band Type:</label>
      <select id="band-type-select" disabled>
        <option value="peaking">Bell (Peaking)</option>
        <option value="lowshelf">Low Shelf</option>
        <option value="highshelf">High Shelf</option>
        <option value="lowpass">Low Pass</option>
        <option value="highpass">High Pass</option>
        <option value="notch">Notch</option>
        <option value="allpass">All Pass</option>
      </select>
    </div>
  </main>

  <!-- FX RACK -->
  <aside id="fx-rack">
    <h3>FX Rack</h3>

    <!-- NEW DYNAMICS PANEL -->
    <div id="dynamics">
      <h4>Dynamics (Master Bus)</h4>

      <label>Threshold: <span id="threshVal">-24</span> dB</label>
      <input id="threshold" type="range" min="-100" max="0" step="1" value="-24">

      <label>Ratio: <span id="ratioVal">4</span>:1</label>
      <input id="ratio" type="range" min="1" max="20" step="1" value="4">

      <label>Attack: <span id="attackVal">0.01</span>s</label>
      <input id="attack" type="range" min="0" max="1" step="0.01" value="0.01">

      <label>Release: <span id="releaseVal">0.25</span>s</label>
      <input id="release" type="range" min="0" max="1" step="0.01" value="0.25">
    </div>

  </aside>

</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const audioContext = new AudioContext();

  // Master mix bus and compressor
  const mixBus = audioContext.createGain();
  const masterCompressor = audioContext.createDynamicsCompressor();

  // Connect master compressor to destination
  mixBus.connect(masterCompressor);
  masterCompressor.connect(audioContext.destination);

  // Dynamics controls linked to master compressor
  const thresholdSlider = document.getElementById("threshold");
  const ratioSlider = document.getElementById("ratio");
  const attackSlider = document.getElementById("attack");
  const releaseSlider = document.getElementById("release");

  function updateMasterDynamics() {
    masterCompressor.threshold.value = Number(thresholdSlider.value);
    masterCompressor.ratio.value = Number(ratioSlider.value);
    masterCompressor.attack.value = Number(attackSlider.value);
    masterCompressor.release.value = Number(releaseSlider.value);

    document.getElementById("threshVal").textContent = thresholdSlider.value;
    document.getElementById("ratioVal").textContent = ratioSlider.value;
    document.getElementById("attackVal").textContent = Number(attackSlider.value).toFixed(2);
    document.getElementById("releaseVal").textContent = Number(releaseSlider.value).toFixed(2);
  }

  thresholdSlider.addEventListener("input", updateMasterDynamics);
  ratioSlider.addEventListener("input", updateMasterDynamics);
  attackSlider.addEventListener("input", updateMasterDynamics);
  releaseSlider.addEventListener("input", updateMasterDynamics);

  updateMasterDynamics();

  const trackNames = [
    "Kick Drum","Snare Drum","Tom 1","Tom 2","Over Head",
    "Bass Guitar","Acoustic Guitar","Keyboard (Nord)",
    "Electric Guitar","Male Vocal","Female Vocal"
  ];

  const tracks = [];
  let selectedTrack = null;
  let selectedBand = null;

  const playButton = document.getElementById("play");
  const stopButton = document.getElementById("stop");
  const addBandButton = document.getElementById("add-band");
  const deleteBandButton = document.getElementById("delete-band");
  const bandTypeSelect = document.getElementById("band-type-select");

  /* =======================
     TRACK LOADING
  ======================= */

  async function loadTracks() {
    tracks.length = 0;
    document.getElementById("track-list").innerHTML = "";
    playButton.disabled = true;
    stopButton.disabled = true;
    addBandButton.disabled = true;
    deleteBandButton.disabled = true;
    bandTypeSelect.disabled = true;

    for (const name of trackNames) {
      try {
        const res = await fetch(`audio/${name}.wav`);
        if (!res.ok) throw new Error(`Failed to load ${name}`);
        const buffer = await audioContext.decodeAudioData(await res.arrayBuffer());

        const gainNode = audioContext.createGain();
        const eqInput = audioContext.createGain();
        const eqOutput = audioContext.createGain();

        // Connect EQ input to output by default (no bands yet)
        eqInput.connect(eqOutput);

        gainNode.connect(mixBus);

        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;

        // Each track's eqOutput connects to gainNode
        eqOutput.connect(gainNode);

        const compressor = audioContext.createDynamicsCompressor();
        compressor.threshold.value = -24;
        compressor.ratio.value = 4;
        compressor.attack.value = 0.01;
        compressor.release.value = 0.25;

        const track = {
          name,
          buffer,
          source: null,
          gainNode,
          eqInput,
          eqOutput,
          eqBands: [],
          muted: false,
          solo: false,
          analyser,
          compressor,
          enabledCompressor: false,
          grMeter: null
        };

        tracks.push(track);
      } catch (err) {
        console.error(err);
        alert(`Error loading track "${name}": ${err.message}`);
      }
    }

    buildTrackUI();

    if (tracks.length > 0) {
      selectedTrack = tracks[0];
      setSelectedBand(null);
      addBandButton.disabled = false;
      playButton.disabled = false;
      stopButton.disabled = false;
    }
  }

  document.getElementById("load").onclick = () => {
    audioContext.resume().then(loadTracks);
  };

  /* =======================
     TRACK UI
  ======================= */

  function buildTrackUI() {
    const list = document.getElementById("track-list");
    list.innerHTML = "";

    tracks.forEach(track => {
      const row = document.createElement("div");
      row.className = "track";
      row.textContent = track.name;

      row.onclick = () => {
        document.querySelectorAll(".track").forEach(t => t.classList.remove("active"));
        row.classList.add("active");
        selectedTrack = track;
        setSelectedBand(null);
        updateDynamicsUI();
        addBandButton.disabled = false;
      };

      const controls = document.createElement("div");
      controls.className = "track-controls";

      const mute = document.createElement("button");
      mute.textContent = "M";
      mute.title = "Mute";
      mute.onclick = e => {
        e.stopPropagation();
        track.muted = !track.muted;
        mute.classList.toggle("muted", track.muted);
        updateMuteSolo();
      };

      const solo = document.createElement("button");
      solo.textContent = "S";
      solo.title = "Solo";
      solo.onclick = e => {
        e.stopPropagation();
        track.solo = !track.solo;
        solo.classList.toggle("soloed", track.solo);
        updateMuteSolo();
      };

      const fader = document.createElement("input");
      fader.type = "range";
      fader.min = 0;
      fader.max = 1;
      fader.step = 0.01;
      fader.value = 0.75;
      fader.title = "Volume";
      fader.oninput = () => {
        track.gainNode.gain.value = fader.value;
      };
      track.gainNode.gain.value = fader.value;

      const grMeter = document.createElement("div");
      grMeter.style.height = "6px";
      grMeter.style.background = "#400";
      grMeter.style.width = "0px";
      track.grMeter = grMeter;

      controls.append(mute, solo, fader, grMeter);
      row.appendChild(controls);
      list.appendChild(row);
    });
  }

  function updateMuteSolo() {
    const anySolo = tracks.some(t => t.solo);
    tracks.forEach(t => {
      if (anySolo) {
        t.gainNode.gain.value = (t.solo && !t.muted) ? 1 : 0;
      } else {
        t.gainNode.gain.value = t.muted ? 0 : 1;
      }
    });
  }

  /* =======================
     PLAYBACK (LOOPING)
  ======================= */

  function play() {
    stop();
    tracks.forEach(track => {
      const src = audioContext.createBufferSource();
      src.buffer = track.buffer;
      src.loop = true;

      // Connect source chain: source → analyser → eqInput → (EQ bands) → eqOutput → gainNode → mixBus
      src.connect(track.analyser);
      track.analyser.connect(track.eqInput);

      rebuildTrackRouting(track);

      src.start();
      track.source = src;
    });

    playButton.disabled = true;
    stopButton.disabled = false;
  }

  function stop() {
    tracks.forEach(track => {
      if (track.source) {
        try { track.source.stop(); } catch(e) {}
        track.source = null;
      }
    });

    playButton.disabled = false;
    stopButton.disabled = true;
  }

  document.getElementById("play").onclick = () => {
    audioContext.resume().then(play);
  };
  document.getElementById("stop").onclick = stop;

  document.body.onclick = () => audioContext.resume();

  /* =======================
     TRACK ROUTING
  ======================= */

  function rebuildTrackRouting(track) {
    try { track.eqInput.disconnect(); } catch(e) {}
    track.eqBands.forEach(b => {
      try { b.node.disconnect(); } catch(e) {}
      // Update node params
      b.node.frequency.value = b.frequency;
      b.node.gain.value = b.gain;
      b.node.Q.value = b.Q;
      b.node.type = b.type;
    });

    let last = track.eqInput;

    track.eqBands.forEach(b => {
      last.connect(b.node);
      last = b.node;
    });

    // Connect to compressor if enabled, else directly to gainNode
    try { track.compressor.disconnect(); } catch(e) {}

    if (track.enabledCompressor) {
      last.connect(track.compressor);
      track.compressor.connect(track.gainNode);
    } else {
      last.connect(track.gainNode);
    }
  }

  /* =======================
     DYNAMICS UI (TRACK SELECTED)
  ======================= */

  function updateDynamicsUI() {
    if (!selectedTrack) return;

    // Currently only UI sync with sliders - you could extend to per-track compressor later
  }

  /* =======================
     EQ ENGINE & CANVAS
  ======================= */

  const canvas = document.getElementById("eq");
  const ctx = canvas.getContext("2d");

  const FREQ_MIN = 20;
  const FREQ_MAX = 20000;
  const GAIN_MIN = -24;
  const GAIN_MAX = 24;

  let draggingBand = null;
  let lastMousePos = null;
  let isDragging = false;
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  let hoveredBandAtDraw = null;

  function freqToX(freq) {
    return (Math.log10(freq / FREQ_MIN) / Math.log10(FREQ_MAX / FREQ_MIN)) * canvas.width;
  }

  function xToFreq(x) {
    return Math.min(Math.max(
      FREQ_MIN * Math.pow(FREQ_MAX / FREQ_MIN, x / canvas.width),
      FREQ_MIN), FREQ_MAX);
  }

  function gainToY(g) {
    return canvas.height - ((g - GAIN_MIN) / (GAIN_MAX - GAIN_MIN)) * canvas.height;
  }

  function yToGain(y) {
    return Math.min(Math.max(
      GAIN_MIN + (1 - y / canvas.height) * (GAIN_MAX - GAIN_MIN),
      GAIN_MIN), GAIN_MAX);
  }

  function setSelectedBand(band) {
    selectedBand = band;
    deleteBandButton.disabled = !band;
    updateBandTypeSelect();
  }

  bandTypeSelect.onchange = () => {
    if (!selectedTrack || !selectedBand) return;
    selectedBand.type = bandTypeSelect.value;
    selectedBand.node.type = bandTypeSelect.value;
    rebuildTrackRouting(selectedTrack);
  };

  function updateBandTypeSelect() {
    bandTypeSelect.disabled = !selectedBand;
    if (selectedBand) bandTypeSelect.value = selectedBand.type;
  }

  document.getElementById("add-band").onclick = () => {
    if (!selectedTrack) return;

    const node = audioContext.createBiquadFilter();
    node.type = "peaking";
    node.frequency.value = 1000;
    node.gain.value = 0;
    node.Q.value = 1;

    const newBand = { node, frequency: 1000, gain: 0, Q: 1, type: "peaking" };

    selectedTrack.eqBands.push(newBand);
    setSelectedBand(newBand);
    rebuildTrackRouting(selectedTrack);
  };

  document.getElementById("delete-band").onclick = () => {
    if (!selectedTrack || !selectedBand) return;
    const idx = selectedTrack.eqBands.indexOf(selectedBand);
    if (idx !== -1) {
      selectedBand.node.disconnect();
      selectedTrack.eqBands.splice(idx, 1);
      setSelectedBand(null);
      rebuildTrackRouting(selectedTrack);
    }
  };

  /* =======================
     DRAWING
  ======================= */

  function drawGrid() {
    ctx.strokeStyle = "#333";
    ctx.fillStyle = "#666";
    ctx.font = "10px sans-serif";

    [20,50,100,200,500,1000,2000,5000,10000,20000].forEach(f => {
      const x = freqToX(f);
      ctx.beginPath();
      ctx.moveTo(x,0);
      ctx.lineTo(x,canvas.height);
      ctx.stroke();
      ctx.fillText(f + " Hz", x + 2, canvas.height - 4);
    });

    // Gain lines
    for (let g = GAIN_MIN; g <= GAIN_MAX; g += 6) {
      const y = gainToY(g);
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(canvas.width,y);
      ctx.stroke();
      ctx.fillText(g + " dB", 4, y - 2);
    }
  }

  function drawCurve() {
    if (!selectedTrack) return;

    ctx.lineWidth = 3;
    ctx.strokeStyle = "#0f0";
    ctx.beginPath();

    const points = 200;
    for (let i = 0; i <= points; i++) {
      const freq = xToFreq(i * canvas.width / points);
      let mag = 1;

      selectedTrack.eqBands.forEach(b => {
        const freqArr = new Float32Array([freq]);
        const magArr = new Float32Array(1);
        const phaseArr = new Float32Array(1);
        b.node.getFrequencyResponse(freqArr, magArr, phaseArr);
        mag *= magArr[0];
      });

      const gainDB = 20 * Math.log10(mag);
      const y = gainToY(gainDB);

      if (i === 0) ctx.moveTo(i * canvas.width / points, y);
      else ctx.lineTo(i * canvas.width / points, y);
    }

    ctx.stroke();
  }

  function drawBands() {
    if (!selectedTrack) return;

    hoveredBandAtDraw = null;

    selectedTrack.eqBands.forEach(band => {
      const x = freqToX(band.frequency);
      const y = gainToY(band.gain);

      ctx.beginPath();
      ctx.arc(x, y, 8, 0, Math.PI * 2);

      if (band === selectedBand) {
        ctx.fillStyle = "#ff0";
        ctx.strokeStyle = "#ffa500";
        ctx.lineWidth = 3;
      } else {
        ctx.fillStyle = "#0f0";
        ctx.strokeStyle = "#080";
        ctx.lineWidth = 1;
      }

      ctx.fill();
      ctx.stroke();

      // Check if mouse near this band for hover (used in mouse move)
      if (lastMousePos) {
        const dx = lastMousePos.x - x;
        const dy = lastMousePos.y - y;
        if (Math.sqrt(dx*dx + dy*dy) < 10) {
          hoveredBandAtDraw = band;
          if (!isDragging) canvas.style.cursor = "grab";
        }
      }
    });

    if (!hoveredBandAtDraw && !isDragging) {
      canvas.style.cursor = "crosshair";
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawGrid();
    drawCurve();
    drawBands();

    requestAnimationFrame(draw);
  }

  /* =======================
     MOUSE EVENTS
  ======================= */

  canvas.addEventListener("mousemove", e => {
    lastMousePos = { x: e.offsetX, y: e.offsetY };

    if (isDragging && draggingBand && selectedTrack) {
      // Calculate new freq and gain from mouse position, limit frequency range and gain range
      let newFreq = xToFreq(e.offsetX - dragOffsetX);
      newFreq = Math.min(Math.max(newFreq, FREQ_MIN), FREQ_MAX);
      let newGain = yToGain(e.offsetY - dragOffsetY);
      newGain = Math.min(Math.max(newGain, GAIN_MIN), GAIN_MAX);

      draggingBand.frequency = newFreq;
      draggingBand.gain = newGain;

      // Update node values
      draggingBand.node.frequency.value = newFreq;
      draggingBand.node.gain.value = newGain;

      rebuildTrackRouting(selectedTrack);
    } else {
      // Change cursor if hovering over a band (done in drawBands)
    }
  });

  canvas.addEventListener("mousedown", e => {
    if (hoveredBandAtDraw && selectedTrack) {
      draggingBand = hoveredBandAtDraw;
      isDragging = true;
      dragOffsetX = e.offsetX - freqToX(draggingBand.frequency);
      dragOffsetY = e.offsetY - gainToY(draggingBand.gain);
      setSelectedBand(draggingBand);
      canvas.style.cursor = "grabbing";
    }
  });

  canvas.addEventListener("mouseup", e => {
    isDragging = false;
    draggingBand = null;
    canvas.style.cursor = "crosshair";
  });

  canvas.addEventListener("mouseleave", e => {
    isDragging = false;
    draggingBand = null;
    canvas.style.cursor = "crosshair";
  });

  /* =======================
     INITIALIZATION
  ======================= */

  draw();

});
</script>
</body>
</html>
