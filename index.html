<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Interactive Web EQ & Dynamics Trainer</title>

<style>
body {
  margin: 0;
  font-family: sans-serif;
  background: #111;
  color: #ddd;
}

#app {
  display: grid;
  grid-template-columns: 260px 1fr 260px;
  height: 100vh;
}

/* TRACK LIST */
#tracks {
  background: #1a1a1a;
  padding: 10px;
  overflow-y: auto;
}

.track {
  padding: 6px;
  border-bottom: 1px solid #333;
  cursor: pointer;
}

.track.active {
  background: #2a2a2a;
}

.track-controls {
  display: flex;
  align-items: center;
  gap: 4px;
  margin-top: 4px;
}

.track-controls button {
  font-size: 10px;
  width: 22px;
  height: 22px;
  background: #333;
  color: #ddd;
  border: none;
  cursor: pointer;
}

.track-controls button.muted {
  background: #b00000;
}

.track-controls button.soloed {
  background: #b0b000;
  color: #000;
}

.track-controls input[type="range"] {
  flex: 1;
}

/* EQ PANEL */
#eq-panel {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 10px;
}

canvas {
  background: #000;
  border: 1px solid #333;
  cursor: crosshair;
}

canvas.band-hover {
  cursor: grab;
}

canvas.band-dragging {
  cursor: grabbing;
}

#controls {
  margin-top: 10px;
  display: flex;
  gap: 10px;
}

button {
  background: #333;
  color: #ddd;
  border: none;
  padding: 8px 12px;
  font-size: 16px;
  cursor: pointer;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Band type selector container */
#band-type-container {
  margin-top: 10px;
  color: #ddd;
  font-size: 14px;
}

#band-type-select {
  background: #222;
  color: #ddd;
  border: 1px solid #444;
  padding: 4px 6px;
  font-size: 14px;
  margin-left: 6px;
  cursor: pointer;
}

/* DYNAMICS BOXES */
#dynamics-container {
  margin-top: 20px;
  width: 100%;
  display: flex;
  justify-content: center;
  gap: 24px;
  color: #ddd;
  font-size: 14px;
  user-select: none;
}

.dynamic-box {
  background: #1a1a1a;
  border: 1px solid #444;
  padding: 12px;
  width: 300px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  border-radius: 6px;
}

.dynamic-box h4 {
  margin: 0 0 6px 0;
  text-align: center;
  color: #8af;
  font-weight: normal;
}

.dynamic-box label {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.dynamic-box select {
  background: #222;
  color: #ddd;
  border: 1px solid #444;
  padding: 4px 6px;
  font-size: 14px;
  cursor: pointer;
  min-width: 140px;
}

/* FX RACK */
#fx-rack {
  background: #1a1a1a;
  padding: 10px;
}

#transport {
  margin-bottom: 10px;
}
</style>
</head>

<body>
<div id="app">

  <!-- TRACKS -->
  <aside id="tracks">
    <div id="transport">
      <button id="load">Load Tracks</button>
      <button id="play">Play</button>
      <button id="stop">Stop</button>
    </div>
    <div id="track-list"></div>
  </aside>

  <!-- EQ -->
  <main id="eq-panel">
    <canvas id="eq" width="900" height="400"></canvas>
    <div id="controls">
      <button id="add-band">Add EQ Band</button>
      <button id="delete-band" disabled>Delete Selected Band</button>
    </div>
    <div id="band-type-container">
      <label for="band-type-select">Band Type:</label>
      <select id="band-type-select" disabled>
        <option value="peaking">Bell (Peaking)</option>
        <option value="lowshelf">Low Shelf</option>
        <option value="highshelf">High Shelf</option>
        <option value="lowpass">Low Pass</option>
        <option value="highpass">High Pass</option>
        <option value="notch">Notch</option>
        <option value="allpass">All Pass</option>
      </select>
    </div>

    <!-- Dynamics Boxes -->
    <div id="dynamics-container">
      <div class="dynamic-box" id="dynamic1">
        <h4>Dynamic Processor 1</h4>
        <label>
          Position:
          <select class="dyn-position">
            <option value="pre">Pre EQ</option>
            <option value="post">Post EQ</option>
          </select>
        </label>
        <label>
          Processor:
          <select class="dyn-type">
            <option value="bypass">Bypass</option>
            <option value="gate">Gate</option>
            <option value="compressor">Compressor</option>
            <option value="deesser">De-Esser</option>
            <option value="expander">Expander</option>
            <option value="limiter">Limiter</option>
          </select>
        </label>
      </div>
      <div class="dynamic-box" id="dynamic2">
        <h4>Dynamic Processor 2</h4>
        <label>
          Position:
          <select class="dyn-position">
            <option value="pre">Pre EQ</option>
            <option value="post">Post EQ</option>
          </select>
        </label>
        <label>
          Processor:
          <select class="dyn-type">
            <option value="bypass">Bypass</option>
            <option value="gate">Gate</option>
            <option value="compressor">Compressor</option>
            <option value="deesser">De-Esser</option>
            <option value="expander">Expander</option>
            <option value="limiter">Limiter</option>
          </select>
        </label>
      </div>
    </div>
  </main>

  <!-- FX RACK -->
  <aside id="fx-rack">
    <h3>FX Rack</h3>
    <p>(Per-track FX coming next)</p>
  </aside>

</div>

<script>
document.addEventListener("DOMContentLoaded", () => {

  /* =======================
     AUDIO ENGINE
  ======================= */

  const audioContext = new AudioContext();
  const mixBus = audioContext.createGain();
  mixBus.connect(audioContext.destination);

  const trackNames = [
    "Kick Drum",
    "Snare Drum",
    "Tom 1",
    "Tom 2",
    "Over Head",
    "Bass Guitar",
    "Acoustic Guitar",
    "Keyboard (Nord)",
    "Electric Guitar",
    "Male Vocal",
    "Female Vocal"
  ];

  const tracks = [];
  let selectedTrack = null;

  /* =======================
     LOAD TRACKS
  ======================= */

  document.getElementById("load").onclick = loadTracks;

  async function loadTracks() {
    tracks.length = 0;
    document.getElementById("track-list").innerHTML = "";

    for (const name of trackNames) {
      const res = await fetch(`audio/${name}.wav`);
      const buffer = await audioContext.decodeAudioData(await res.arrayBuffer());

      // Basic nodes for routing:
      // source -> dyn1(pre or post) -> eqInput -> eqBands chain -> eqOutput -> dyn2(pre or post) -> gain -> mixBus

      const gainNode = audioContext.createGain();

      // EQ nodes:
      const eqInput = audioContext.createGain();
      const eqOutput = audioContext.createGain();

      // Dynamic processors stubs - create nodes but don't connect yet
      const dynamicProcessors = [
        { // Dynamic Processor 1
          position: "pre", // "pre" or "post"
          type: "bypass", // current processor type
          node: createBypassNode()
        },
        { // Dynamic Processor 2
          position: "post",
          type: "bypass",
          node: createBypassNode()
        }
      ];

      tracks.push({
        name,
        buffer,
        source: null,
        gainNode,
        eqInput,
        eqOutput,
        eqBands: [],
        muted: false,
        solo: false,
        dynamics: dynamicProcessors
      });
    }

    buildTrackUI();
    selectedTrack = tracks[0];
    setSelectedBand(null);
    updateDynamicsUI();
  }

  /* =======================
     TRACK UI
  ======================= */

  function buildTrackUI() {
    const list = document.getElementById("track-list");
    list.innerHTML = "";

    tracks.forEach(track => {
      const row = document.createElement("div");
      row.className = "track";
      row.textContent = track.name;

      row.onclick = () => {
        document.querySelectorAll(".track").forEach(t => t.classList.remove("active"));
        row.classList.add("active");
        selectedTrack = track;
        setSelectedBand(null);
        updateDynamicsUI();
      };

      const controls = document.createElement("div");
      controls.className = "track-controls";

      const mute = document.createElement("button");
      mute.textContent = "M";
      mute.onclick = e => {
        e.stopPropagation();
        track.muted = !track.muted;
        mute.classList.toggle("muted", track.muted);
        updateMuteSolo();
      };

      const solo = document.createElement("button");
      solo.textContent = "S";
      solo.onclick = e => {
        e.stopPropagation();
        track.solo = !track.solo;
        solo.classList.toggle("soloed", track.solo);
        updateMuteSolo();
      };

      const fader = document.createElement("input");
      fader.type = "range";
      fader.min = 0;
      fader.max = 1;
      fader.step = 0.01;
      fader.value = 1;
      fader.oninput = () => track.gainNode.gain.value = fader.value;

      controls.append(mute, solo, fader);
      row.appendChild(controls);
      list.appendChild(row);
    });
  }

  function updateMuteSolo() {
    const anySolo = tracks.some(t => t.solo);
    tracks.forEach(t => {
      if (anySolo) {
        t.gainNode.gain.value = t.solo && !t.muted ? 1 : 0;
      } else {
        t.gainNode.gain.value = t.muted ? 0 : 1;
      }
    });
  }

  /* =======================
     PLAYBACK
  ======================= */

  document.getElementById("play").onclick = play;
  document.getElementById("stop").onclick = stop;
  document.body.onclick = () => audioContext.resume();

  function play() {
    stop();
    tracks.forEach(track => {
      const src = audioContext.createBufferSource();
      src.buffer = track.buffer;
      // Connect source directly; chain connections done later in connectDynamicChain
      track.source = src;

      // Connect source to first node in chain based on dyn positions:
      connectDynamicChain(track);

      src.start();
    });
  }

  function stop() {
    tracks.forEach(track => {
      if (track.source) {
        track.source.stop();
        track.source.disconnect();
        track.source = null;
      }
    });
  }

  /* =======================
     DYNAMIC PROCESSORS - NODE CREATORS (STUBS)
  ======================= */

  function createBypassNode() {
    const gainNode = audioContext.createGain();
    gainNode.gain.value = 1;
    return gainNode;
  }

  function createCompressorNode() {
    return audioContext.createDynamicsCompressor();
  }

  // Placeholder for gate, de-esser, expander, limiter:
  // For now, just bypass gain nodes. Future: implement proper DSP or find libraries.
  function createGateNode() {
    return createBypassNode();
  }

  function createDeEsserNode() {
    return createBypassNode();
  }

  function createExpanderNode() {
    return createBypassNode();
  }

  function createLimiterNode() {
    // Could be DynamicsCompressorNode with extreme ratio, or bypass for now
    return createBypassNode();
  }

  /* =======================
     CONNECT DYNAMIC CHAIN BASED ON SETTINGS
  ======================= */

  function connectDynamicChain(track) {
    const dyn1 = track.dynamics[0];
    const dyn2 = track.dynamics[1];

    // Disconnect all nodes safely
    if (track.source && track.source.disconnect) {
      try { track.source.disconnect(); } catch {}
    }
    if (dyn1.node && dyn1.node.disconnect) {
      try { dyn1.node.disconnect(); } catch {}
    }
    if (track.eqInput && track.eqInput.disconnect) {
      try { track.eqInput.disconnect(); } catch {}
    }
    if (track.eqOutput && track.eqOutput.disconnect) {
      try { track.eqOutput.disconnect(); } catch {}
    }
    if (dyn2.node && dyn2.node.disconnect) {
      try { dyn2.node.disconnect(); } catch {}
    }
    if (track.gainNode && track.gainNode.disconnect) {
      try { track.gainNode.disconnect(); } catch {}
    }

    // Safety check - if any node missing, skip connection to avoid errors
    if (!track.source || !dyn1.node || !track.eqInput || !track.eqOutput || !dyn2.node || !track.gainNode) {
      console.warn("Missing audio nodes in track for dynamic chain connection", track);
      return;
    }

    // Rebuild EQ nodes chain before connecting
    rebuildEQ(track);

    // Chain from source:
    if (dyn1.position === "pre" && dyn2.position === "post") {
      track.source.connect(dyn1.node);
      dyn1.node.connect(track.eqInput);
      track.eqOutput.connect(dyn2.node);
      dyn2.node.connect(track.gainNode);
    } else if (dyn1.position === "pre" && dyn2.position === "pre") {
      track.source.connect(dyn1.node);
      dyn1.node.connect(dyn2.node);
      dyn2.node.connect(track.eqInput);
      track.eqOutput.connect(track.gainNode);
    } else if (dyn1.position === "post" && dyn2.position === "pre") {
      track.source.connect(dyn2.node);
      dyn2.node.connect(track.eqInput);
      track.eqOutput.connect(dyn1.node);
      dyn1.node.connect(track.gainNode);
    } else if (dyn1.position === "post" && dyn2.position === "post") {
      track.source.connect(track.eqInput);
      track.eqOutput.connect(dyn1.node);
      dyn1.node.connect(dyn2.node);
      dyn2.node.connect(track.gainNode);
    } else {
      // fallback default chain
      track.source.connect(track.eqInput);
      track.eqOutput.connect(track.gainNode);
    }
  }

  /* =======================
     EQ ENGINE & INTERACTION
  ======================= */

  const canvas = document.getElementById("eq");
  const ctx = canvas.getContext("2d");

  const FREQ_MIN = 20;
  const FREQ_MAX = 20000;
  const GAIN_MIN = -24;
  const GAIN_MAX = 24;

  let draggingBand = null;
  let selectedBand = null;
  let lastMousePos = null;

  function freqToX(freq) {
    return (Math.log10(freq / FREQ_MIN) / Math.log10(FREQ_MAX / FREQ_MIN)) * canvas.width;
  }

  function xToFreq(x) {
    const f = FREQ_MIN * Math.pow(FREQ_MAX / FREQ_MIN, x / canvas.width);
    return Math.min(Math.max(f, FREQ_MIN), FREQ_MAX);
  }

  function gainToY(g) {
    return canvas.height - ((g - GAIN_MIN) / (GAIN_MAX - GAIN_MIN)) * canvas.height;
  }

  function yToGain(y) {
    const g = GAIN_MIN + (1 - y / canvas.height) * (GAIN_MAX - GAIN_MIN);
    return Math.min(Math.max(g, GAIN_MIN), GAIN_MAX);
  }

  function rebuildEQ(track) {
    try { track.eqInput.disconnect(); } catch(e) {}
    track.eqBands.forEach(band => {
      try { band.node.disconnect(); } catch {}
    });

    if (track.eqBands.length === 0) {
      track.eqInput.connect(track.eqOutput);
      return;
    }

    let prevNode = track.eqInput;
    track.eqBands.forEach(band => {
      band.node.type = band.type;
      band.node.frequency.value = band.freq;
      band.node.gain.value = band.gain;
      band.node.Q.value = band.Q;
      prevNode.connect(band.node);
      prevNode = band.node;
    });

    prevNode.connect(track.eqOutput);
  }

  function drawEQ() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw frequency grid lines & labels
    ctx.fillStyle = "#666";
    ctx.font = "12px monospace";
    ctx.textAlign = "center";

    const freqs = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
    freqs.forEach(f => {
      const x = freqToX(f);
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.strokeStyle = "#333";
      ctx.stroke();
      ctx.fillText(f >= 1000 ? (f/1000) + "k" : f, x, canvas.height - 4);
    });

    // Draw gain lines
    ctx.strokeStyle = "#333";
    ctx.beginPath();
    for (let g = GAIN_MIN; g <= GAIN_MAX; g += 6) {
      const y = gainToY(g);
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
    }
    ctx.stroke();

    // Draw bands
    if (!selectedTrack) return;

    selectedTrack.eqBands.forEach((band, i) => {
      const x = freqToX(band.freq);
      const y = gainToY(band.gain);

      // Draw band point
      ctx.beginPath();
      ctx.arc(x, y, 8, 0, 2 * Math.PI);
      ctx.fillStyle = i === selectedBand ? "#0af" : "#08a";
      ctx.fill();

      // Draw band Q radius (circle)
      const qRadius = 60 / band.Q;
      ctx.strokeStyle = i === selectedBand ? "#0af" : "#08a";
      ctx.beginPath();
      ctx.arc(x, y, qRadius, 0, 2 * Math.PI);
      ctx.stroke();
    });
  }

  function setSelectedBand(i) {
    selectedBand = i;
    document.getElementById("delete-band").disabled = i === null;
    updateBandTypeUI();
    drawEQ();
  }

  function updateBandTypeUI() {
    const select = document.getElementById("band-type-select");
    if (selectedBand === null || !selectedTrack) {
      select.disabled = true;
      select.value = "";
      return;
    }
    select.disabled = false;
    select.value = selectedTrack.eqBands[selectedBand].type;
  }

  // Add band
  document.getElementById("add-band").onclick = () => {
    if (!selectedTrack) return;
    const band = {
      freq: 1000,
      gain: 0,
      Q: 1,
      type: "peaking",
      node: audioContext.createBiquadFilter()
    };
    selectedTrack.eqBands.push(band);
    rebuildEQ(selectedTrack);
    setSelectedBand(selectedTrack.eqBands.length - 1);
  };

  // Delete band
  document.getElementById("delete-band").onclick = () => {
    if (selectedBand === null || !selectedTrack) return;
    selectedTrack.eqBands.splice(selectedBand, 1);
    rebuildEQ(selectedTrack);
    setSelectedBand(null);
  };

  // Band type change
  document.getElementById("band-type-select").onchange = e => {
    if (selectedBand === null || !selectedTrack) return;
    selectedTrack.eqBands[selectedBand].type = e.target.value;
    rebuildEQ(selectedTrack);
    drawEQ();
  };

  // Canvas mouse interaction for moving freq/gain/Q
  canvas.onmousedown = e => {
    if (!selectedTrack) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Find band within radius
    const radius = 10;
    for (let i = 0; i < selectedTrack.eqBands.length; i++) {
      const band = selectedTrack.eqBands[i];
      const bx = freqToX(band.freq);
      const by = gainToY(band.gain);
      if (Math.hypot(bx - x, by - y) < radius) {
        draggingBand = i;
        setSelectedBand(i);
        lastMousePos = {x, y};
        canvas.classList.add("band-dragging");
        break;
      }
    }
  };

  canvas.onmouseup = e => {
    draggingBand = null;
    lastMousePos = null;
    canvas.classList.remove("band-dragging");
  };

  canvas.onmouseleave = e => {
    draggingBand = null;
    lastMousePos = null;
    canvas.classList.remove("band-dragging");
  };

  canvas.onmousemove = e => {
    if (draggingBand === null || !selectedTrack) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const band = selectedTrack.eqBands[draggingBand];

    if (!lastMousePos) {
      lastMousePos = {x, y};
      return;
    }

    const dx = x - lastMousePos.x;
    const dy = y - lastMousePos.y;

    // Adjust frequency with horizontal movement
    let freq = xToFreq(freqToX(band.freq) + dx);
    freq = Math.min(Math.max(freq, FREQ_MIN), FREQ_MAX);

    // Adjust gain with vertical movement
    let gain = yToGain(y);
    gain = Math.min(Math.max(gain, GAIN_MIN), GAIN_MAX);

    // Adjust Q with shift key (horizontal drag while holding shift)
    let Q = band.Q;
    if (e.shiftKey) {
      Q += dx * 0.01;
      Q = Math.min(Math.max(Q, 0.1), 20);
    }

    band.freq = freq;
    band.gain = gain;
    band.Q = Q;

    rebuildEQ(selectedTrack);
    drawEQ();

    lastMousePos = {x, y};
  };

  /* =======================
     DYNAMICS UI & HANDLERS
  ======================= */

  const dynamicContainers = [document.getElementById("dynamic1"), document.getElementById("dynamic2")];

  function updateDynamicsUI() {
    if (!selectedTrack) return;
    dynamicContainers.forEach((container, idx) => {
      const posSelect = container.querySelector(".dyn-position");
      const typeSelect = container.querySelector(".dyn-type");

      const dyn = selectedTrack.dynamics[idx];
      posSelect.value = dyn.position;
      typeSelect.value = dyn.type;
    });
  }

  dynamicContainers.forEach((container, idx) => {
    const posSelect = container.querySelector(".dyn-position");
    const typeSelect = container.querySelector(".dyn-type");

    posSelect.onchange = e => {
      if (!selectedTrack) return;
      selectedTrack.dynamics[idx].position = e.target.value;
      connectDynamicChain(selectedTrack);
    };

    typeSelect.onchange = e => {
      if (!selectedTrack) return;

      const newType = e.target.value;
      selectedTrack.dynamics[idx].type = newType;

      // Disconnect old node safely
      try {
        if (selectedTrack.dynamics[idx].node && selectedTrack.dynamics[idx].node.disconnect) {
          selectedTrack.dynamics[idx].node.disconnect();
        }
      } catch {}

      // Create new processor node based on type
      let newNode = null;
      switch(newType) {
        case "bypass": newNode = createBypassNode(); break;
        case "compressor": newNode = createCompressorNode(); break;
        case "gate": newNode = createGateNode(); break;
        case "deesser": newNode = createDeEsserNode(); break;
        case "expander": newNode = createExpanderNode(); break;
        case "limiter": newNode = createLimiterNode(); break;
        default: newNode = createBypassNode(); break;
      }
      selectedTrack.dynamics[idx].node = newNode;

      connectDynamicChain(selectedTrack);
    };
  });

  /* =======================
     INITIAL DRAW & SETUP
  ======================= */

  function init() {
    buildTrackUI();
    drawEQ();
  }

  init();

});
</script>
</body>
</html>
