<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Web EQ Trainer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  body {
    margin: 0;
    font-family: sans-serif;
    background: #1e1e1e;
    color: #eee;
  }

  #app {
    display: grid;
    grid-template-columns: 200px 1fr 200px;
    height: calc(100vh - 60px);
  }

  aside, main {
    padding: 10px;
    border-right: 1px solid #333;
  }

  #eq-panel {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  canvas {
    background: #111;
    border: 1px solid #444;
  }

  footer {
    height: 60px;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    background: #111;
    border-top: 1px solid #333;
  }

  button {
    background: #333;
    color: white;
    border: none;
    padding: 6px 12px;
    cursor: pointer;
  }

  button:hover {
    background: #555;
  }
</style>
</head>

<body>
  <div id="app">
    <aside id="audio-list">
      <h3>Audio</h3>
      <button id="load-audio">Load Demo</button>
    </aside>

    <main id="eq-panel">
      <canvas id="eq-canvas" width="900" height="400"></canvas>
    </main>

    <aside id="fx-rack">
      <h3>FX</h3>
      <p>Coming soon</p>
    </aside>
  </div>

  <footer>
    <button id="play">Play</button>
    <button id="stop">Stop</button>
  </footer>

<script type="module">
/* ======================================================
   AUDIO ENGINE
====================================================== */

const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const masterGain = audioContext.createGain();
masterGain.connect(audioContext.destination);

let audioBuffer = null;
let sourceNode = null;

const eqBands = [];
const analyser = audioContext.createAnalyser();
analyser.fftSize = 2048;
const bufferLength = analyser.frequencyBinCount;
const dataArray = new Uint8Array(bufferLength);

function getCombinedEQResponse(f) {
  let mag = 1;

  eqBands.forEach(band => {
    const freqArray = new Float32Array([f]);
    const magResponse = new Float32Array(1);
    const phaseResponse = new Float32Array(1);
    band.node.getFrequencyResponse(freqArray, magResponse, phaseResponse);

    mag *= magResponse[0];
  });

  return mag;
}

/* ------------------------------------------------------
   LOAD AUDIO
------------------------------------------------------ */
async function loadAudio() {
  const res = await fetch("./audio/demo.wav");
  const buf = await res.arrayBuffer();
  audioBuffer = await audioContext.decodeAudioData(buf);
}

/* ------------------------------------------------------
   CREATE SOURCE
------------------------------------------------------ */
function createSource() {
  sourceNode = audioContext.createBufferSource();
  sourceNode.buffer = audioBuffer;
  sourceNode.loop = true;
}

/* ------------------------------------------------------
   EQ BAND
------------------------------------------------------ */
function addEQBand({ frequency = 1000, gain = 0, Q = 1, type = "peaking" } = {}) {
  const node = audioContext.createBiquadFilter();
  node.type = type;
  node.frequency.value = frequency;
  node.gain.value = gain;
  node.Q.value = Q;

  eqBands.push({ node });
  function rebuildGraph() {
  if (!sourceNode) return;

  sourceNode.disconnect();
  eqBands.forEach(b => b.node.disconnect());

  let node = sourceNode;
  eqBands.forEach(b => {
    node.connect(b.node);
    node = b.node;
  });

  node.connect(analyser);
  analyser.connect(masterGain);
}

}

/* ------------------------------------------------------
   GRAPH REBUILD
------------------------------------------------------ */
function rebuildGraph() {
  if (!sourceNode) return;

  sourceNode.disconnect();
  eqBands.forEach(b => b.node.disconnect());

  let node = sourceNode;
  eqBands.forEach(b => {
    node.connect(b.node);
    node = b.node;
  });

  node.connect(masterGain);
}

/* ------------------------------------------------------
   TRANSPORT
------------------------------------------------------ */
function play() {
  if (audioContext.state === "suspended") audioContext.resume();

  if (sourceNode) {
    sourceNode.stop();
    sourceNode.disconnect();
  }

  createSource();
  rebuildGraph();
  sourceNode.start();
}

function stop() {
  if (!sourceNode) return;
  sourceNode.stop();
  sourceNode.disconnect();
  sourceNode = null;
}

/* ======================================================
   EQ CANVAS
====================================================== */

const canvas = document.getElementById("eq-canvas");
const ctx = canvas.getContext("2d");

const FREQ_MIN = 20;
const FREQ_MAX = 20000;
const GAIN_MIN = -24;
const GAIN_MAX = 24;

let activeBand = null;
let dragging = false;

/* ------------------------------------------------------
   MATH HELPERS
------------------------------------------------------ */
function freqToX(freq) {
  return (
    Math.log10(freq / FREQ_MIN) /
    Math.log10(FREQ_MAX / FREQ_MIN)
  ) * canvas.width;
}

function xToFreq(x) {
  return FREQ_MIN * Math.pow(FREQ_MAX / FREQ_MIN, x / canvas.width);
}

function gainToY(gain) {
  return canvas.height / 2 - (gain / (GAIN_MAX - GAIN_MIN)) * canvas.height;
}

function yToGain(y) {
  return ((canvas.height / 2 - y) / canvas.height) * (GAIN_MAX - GAIN_MIN);
}

/* ------------------------------------------------------
   DRAWING
------------------------------------------------------ */
function drawGrid() {
  ctx.strokeStyle = "#333";
  [20,50,100,200,500,1000,2000,5000,10000,20000].forEach(f => {
    const x = freqToX(f);
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  });

  ctx.strokeStyle = "#555";
  ctx.beginPath();
  ctx.moveTo(0, canvas.height / 2);
  ctx.lineTo(canvas.width, canvas.height / 2);
  ctx.stroke();
}

function drawBands() {
  eqBands.forEach(b => {
    const x = freqToX(b.node.frequency.value);
    const y = gainToY(b.node.gain.value);

    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fillStyle = "#4fc3f7";
    ctx.fill();
  });
}

function drawEQ() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#111";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  drawGrid();

  // Draw frequency spectrum analyzer bars
  analyser.getByteFrequencyData(dataArray);

  ctx.fillStyle = "#4caf50";
  const barWidth = canvas.width / bufferLength;
  for(let i = 0; i < bufferLength; i++) {
    const barHeight = (dataArray[i] / 255) * canvas.height;
    const x = i * barWidth;
    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
  }

  // Draw EQ response curve
  ctx.beginPath();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#ff4081";
  for (let x = 0; x < canvas.width; x++) {
    const freq = xToFreq(x);
    const mag = getCombinedEQResponse(freq);
    const gainDb = 20 * Math.log10(mag);
    const y = gainToY(gainDb);
    if (x === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  drawBands();

  requestAnimationFrame(drawEQ);
}


/* ------------------------------------------------------
   INTERACTION
------------------------------------------------------ */
function getBandAt(x, y) {
  return eqBands.find(b => {
    const bx = freqToX(b.node.frequency.value);
    const by = gainToY(b.node.gain.value);
    return Math.hypot(bx - x, by - y) < 8;
  });
}

canvas.addEventListener("mousedown", e => {
  const r = canvas.getBoundingClientRect();
  activeBand = getBandAt(e.clientX - r.left, e.clientY - r.top);
  dragging = !!activeBand;
});

canvas.addEventListener("mousemove", e => {
  if (!dragging || !activeBand) return;
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;

  activeBand.node.frequency.value = Math.min(FREQ_MAX, Math.max(FREQ_MIN, xToFreq(x)));
  activeBand.node.gain.value = Math.min(GAIN_MAX, Math.max(GAIN_MIN, yToGain(y)));
});

canvas.addEventListener("mouseup", () => {
  dragging = false;
  activeBand = null;
});

canvas.addEventListener("wheel", e => {
  if (!activeBand) return;
  e.preventDefault();
  activeBand.node.Q.value = Math.max(0.1, Math.min(18, activeBand.node.Q.value + e.deltaY * -0.01));
});

/* ======================================================
   INIT
====================================================== */

document.getElementById("load-audio").onclick = async () => {
  await loadAudio();
  addEQBand({ frequency: 1000, gain: 6 });
  addEQBand({ frequency: 300, gain: -6 });
};

document.getElementById("play").onclick = play;
document.getElementById("stop").onclick = stop;

drawEQ();
</script>
  
<body>
  <div id="app">
    <aside id="audio-list">
      <h3>Audio Files</h3>
      <button data-audio="./audio/demo.wav">Demo Track</button>
    </aside>

    <main id="eq-panel">
      <canvas id="eq-canvas" width="800" height="400"></canvas>
    </main>

    <aside id="fx-rack">
      <h3>FX</h3>
      <p>Coming soon</p>
    </aside>
  </div>

  <footer>
    <button id="play">Play</button>
    <button id="stop">Stop</button>
  </footer>

  <script type="module">
    /* audio engine stays here */
  </script>
</body>
</html>
