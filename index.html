<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Audio Training EQ + Dynamics</title>
<style>
  body {
    font-family: monospace, monospace;
    background: #111;
    color: #eee;
    margin: 0; padding: 0;
    display: flex;
    height: 100vh;
  }
  #track-list {
    width: 180px;
    background: #222;
    overflow-y: auto;
    padding: 10px;
    box-sizing: border-box;
  }
  .track {
    padding: 6px;
    margin-bottom: 4px;
    background: #333;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
  }
  .track.active {
    background: #0a0;
    font-weight: bold;
  }
  .track button {
    margin-left: auto;
    margin-right: 4px;
    cursor: pointer;
    width: 28px;
    height: 24px;
    font-weight: bold;
    border: none;
    border-radius: 4px;
    color: #eee;
    background: #444;
    transition: background-color 0.2s ease;
  }
  .track button:hover {
    background: #666;
  }
  .mute-button.muted {
    background: #a00 !important;
  }
  .solo-button.soloed {
    background: #aa0 !important;
    color: #222 !important;
  }
  .volume-slider {
    width: 60px;
    margin-left: 6px;
  }
  #main {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 10px;
    box-sizing: border-box;
  }
  canvas {
    background: #000;
    width: 100%;
    height: 300px;
    border: 1px solid #555;
  }
  #controls {
    margin-top: 10px;
  }
  button {
    background: #222;
    border: 1px solid #444;
    color: #eee;
    padding: 6px 12px;
    margin-right: 6px;
    cursor: pointer;
    border-radius: 4px;
  }
  button:disabled {
    color: #555;
    border-color: #222;
    cursor: default;
  }
  #dynamic-container {
    display: flex;
    gap: 20px;
    margin-top: 20px;
  }
  .dynamic-box {
    background: #222;
    border-radius: 6px;
    padding: 12px;
    flex: 1;
    min-width: 280px;
    font-size: 14px;
  }
  .dynamic-box h4 {
    margin: 0 0 10px 0;
  }
  label {
    display: block;
    margin-bottom: 8px;
    cursor: pointer;
  }
  select {
    width: 100%;
    padding: 4px;
    background: #111;
    border: 1px solid #444;
    color: #eee;
    border-radius: 4px;
    font-family: monospace, monospace;
  }
  .dyn-params {
    margin-top: 10px;
  }
  .dyn-params > div {
    margin-bottom: 8px;
  }
  .dyn-params label {
    display: inline-block;
    width: 130px;
    font-weight: normal;
  }
  .dyn-params input[type=range] {
    vertical-align: middle;
    width: 120px;
    margin-left: 6px;
    margin-right: 6px;
  }
</style>
</head>
<body>

<div id="track-list">
  <button id="load-tracks">Load Tracks</button>
</div>

<div id="main">
  <canvas id="eq-canvas" width="800" height="300"></canvas>
  <div id="controls">
    <button id="play-button" disabled>Play</button>
    <button id="stop-button" disabled>Stop</button>
    <button id="add-band" disabled>Add EQ Band</button>
    <button id="delete-band" disabled>Delete EQ Band</button>
    <label style="margin-left:20px; user-select:none;">
      Band Type:
      <select id="band-type-select" disabled>
        <option value="peaking">Bell</option>
        <option value="lowshelf">Low Shelf</option>
        <option value="highshelf">High Shelf</option>
        <option value="lpf">Low Pass Filter</option>
        <option value="hpf">High Pass Filter</option>
      </select>
    </label>
  </div>

  <div id="dynamic-container">
    <div class="dynamic-box" id="dynamic1">
      <h4>Dynamic Processor 1</h4>
      <label>
        Position:
        <select class="dyn-position">
          <option value="pre">Pre EQ</option>
          <option value="post">Post EQ</option>
        </select>
      </label>
      <label>
        Processor:
        <select class="dyn-type">
          <option value="bypass">Bypass</option>
          <option value="gate">Gate</option>
          <option value="compressor">Compressor</option>
          <option value="deesser">De-Esser</option>
          <option value="expander">Expander</option>
          <option value="limiter">Limiter</option>
        </select>
      </label>
      <div class="dyn-params">No parameters</div>
    </div>

    <div class="dynamic-box" id="dynamic2">
      <h4>Dynamic Processor 2</h4>
      <label>
        Position:
        <select class="dyn-position">
          <option value="pre">Pre EQ</option>
          <option value="post">Post EQ</option>
        </select>
      </label>
      <label>
        Processor:
        <select class="dyn-type">
          <option value="bypass">Bypass</option>
          <option value="gate">Gate</option>
          <option value="compressor">Compressor</option>
          <option value="deesser">De-Esser</option>
          <option value="expander">Expander</option>
          <option value="limiter">Limiter</option>
        </select>
      </label>
      <div class="dyn-params">No parameters</div>
    </div>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();

  const trackNames = [
    "Kick Drum",
    "Snare Drum",
    "Tom 1",
    "Tom 2",
    "Over Head",
    "Bass Guitar",
    "Acoustic Guitar",
    "Keyboard (Nord)",
    "Electric Guitar",
    "Male Vocal",
    "Female Vocal"
  ];

  const FREQ_MIN = 20;
  const FREQ_MAX = 20000;
  const GAIN_MIN = -24;
  const GAIN_MAX = 24;

  // UI Elements
  const loadTracksBtn = document.getElementById("load-tracks");
  const trackListEl = document.getElementById("track-list");
  const playBtn = document.getElementById("play-button");
  const stopBtn = document.getElementById("stop-button");
  const addBandBtn = document.getElementById("add-band");
  const deleteBandBtn = document.getElementById("delete-band");
  const bandTypeSelect = document.getElementById("band-type-select");
  const canvas = document.getElementById("eq-canvas");
  const ctx = canvas.getContext("2d");
  const dynBoxes = [...document.querySelectorAll(".dynamic-box")];

  // State
  let tracks = [];
  let selectedTrack = null;
  let selectedBand = null;
  let draggingBand = null;

  // Audio source + nodes per track
  class Track {
    constructor(name) {
      this.name = name;
      this.audioBuffer = null;
      this.sourceNode = null;
      this.gainNode = audioContext.createGain();

      this.mute = false;
      this.solo = false;

      this.eqBands = [];
      this.eqInput = audioContext.createGain();
      this.eqOutput = audioContext.createGain();

      // Dynamics processors slots
      this.dynamics = [
        { position: "pre", type: "bypass", node: createBypassNode() },
        { position: "post", type: "bypass", node: createBypassNode() }
      ];

      this.volume = 1.0;

      this.updateAudioGraph();
    }

    updateAudioGraph() {
      if (this.sourceNode) {
        this.sourceNode.disconnect();
      }
      if (this.eqInput) {
        this.eqInput.disconnect();
      }
      if (this.eqOutput) {
        this.eqOutput.disconnect();
      }
      if (this.gainNode) {
        this.gainNode.disconnect();
      }
      this.dynamics.forEach(dyn => dyn.node.disconnect());

      if (this.sourceNode) {
        this.sourceNode.connect(this.dynamics[0].node);
        this.dynamics[0].node.connect(this.eqInput);
      }

      rebuildEQ(this);

      this.eqOutput.connect(this.dynamics[1].node);
      this.dynamics[1].node.connect(this.gainNode);
      this.gainNode.connect(audioContext.destination);

      this.gainNode.gain.value = this.mute ? 0 : this.volume;
    }

    play() {
      if (!this.audioBuffer) return;
      this.stop();
      this.sourceNode = audioContext.createBufferSource();
      this.sourceNode.buffer = this.audioBuffer;
      this.updateAudioGraph();
      this.sourceNode.start();
      this.sourceNode.onended = () => {
        this.sourceNode = null;
        stopBtn.disabled = true;
        playBtn.disabled = false;
      };
    }

    stop() {
      if (this.sourceNode) {
        try { this.sourceNode.stop(); } catch {}
        this.sourceNode.disconnect();
        this.sourceNode = null;
      }
    }
  }

  // Audio Node creators for dynamics
  function createBypassNode() {
    return audioContext.createGain();
  }
  function createCompressorNode() {
    return audioContext.createDynamicsCompressor();
  }
  function createGateNode() {
    return audioContext.createGain();
  }
  function createDeEsserNode() {
    return audioContext.createGain();
  }
  function createExpanderNode() {
    return audioContext.createGain();
  }
  function createLimiterNode() {
    return audioContext.createGain();
  }

  // Load audio files
  async function loadTracks() {
    tracks = [];
    trackListEl.querySelectorAll(".track").forEach(t => t.remove());

    for (const name of trackNames) {
      const track = new Track(name);
      try {
        const response = await fetch(`audio/${name}.wav`);
        const arrayBuffer = await response.arrayBuffer();
        track.audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
      } catch (e) {
        console.warn("Failed loading", name, e);
      }
      tracks.push(track);

      const trackEl = document.createElement("div");
      trackEl.className = "track";
      trackEl.textContent = name;

      const muteBtn = document.createElement("button");
      muteBtn.textContent = "M";
      muteBtn.className = "mute-button";
      muteBtn.title = "Mute";
      muteBtn.onclick = (e) => {
        e.stopPropagation();
        track.mute = !track.mute;
        muteBtn.classList.toggle("muted", track.mute);
        track.updateAudioGraph();
      };
      trackEl.appendChild(muteBtn);

      const soloBtn = document.createElement("button");
      soloBtn.textContent = "S";
      soloBtn.className = "solo-button";
      soloBtn.title = "Solo";
      soloBtn.onclick = (e) => {
        e.stopPropagation();
        track.solo = !track.solo;
        soloBtn.classList.toggle("soloed", track.solo);
        updateSoloStates();
      };
      trackEl.appendChild(soloBtn);

      const volSlider = document.createElement("input");
      volSlider.type = "range";
      volSlider.min = 0;
      volSlider.max = 1;
      volSlider.step = 0.01;
      volSlider.value = 1.0;
      volSlider.className = "volume-slider";
      volSlider.title = "Volume";
      volSlider.oninput = () => {
        track.volume = parseFloat(volSlider.value);
        track.updateAudioGraph();
      };
      trackEl.appendChild(volSlider);

      trackEl.onclick = () => {
        selectedTrack = track;
        selectedBand = null;
        setSelectedTrackUI();
        updateDynamicsUI();
        drawEQ();
        playBtn.disabled = false;
      };

      trackListEl.appendChild(trackEl);
    }

    if (tracks.length > 0) {
      selectedTrack = tracks[0];
      setSelectedTrackUI();
      updateDynamicsUI();
      drawEQ();
      addBandBtn.disabled = false;
      playBtn.disabled = false;
    }
  }

  function updateSoloStates() {
    const anySolo = tracks.some(t => t.solo);
    tracks.forEach(t => {
      if (anySolo) {
        t.mute = !t.solo;
      } else {
        t.mute = false;
      }
      t.updateAudioGraph();
      const trackDivs = [...trackListEl.querySelectorAll(".track")];
      trackDivs.forEach(div => {
        const name = div.firstChild.textContent;
        const track = tracks.find(t => t.name === name);
        const muteBtn = div.querySelector(".mute-button");
        if (muteBtn) muteBtn.classList.toggle("muted", track.mute);
      });
    });
  }

  function freqToX(freq) {
    const minLog = Math.log10(FREQ_MIN);
    const maxLog = Math.log10(FREQ_MAX);
    const freqLog = Math.log10(freq);
    const norm = (freqLog - minLog) / (maxLog - minLog);
    return norm * canvas.width;
  }

  function xToFreq(x) {
    const minLog = Math.log10(FREQ_MIN);
    const maxLog = Math.log10(FREQ_MAX);
    const freqLog = minLog + (x / canvas.width) * (maxLog - minLog);
    return Math.pow(10, freqLog);
  }

  function gainToY(gain) {
    const norm = (gain - GAIN_MIN) / (GAIN_MAX - GAIN_MIN);
    return canvas.height * (1 - norm);
  }

  function yToGain(y) {
    const norm = 1 - (y / canvas.height);
    return GAIN_MIN + norm * (GAIN_MAX - GAIN_MIN);
  }

  function rebuildEQ(track) {
    track.eqBands.forEach(band => band.node.disconnect());

    if (track.eqBands.length === 0) {
      track.eqInput.connect(track.eqOutput);
      return;
    }

    let prevNode = track.eqInput;
    track.eqBands.forEach(band => {
      band.node.type = band.type === "lpf" ? "lowpass" :
                      band.type === "hpf" ? "highpass" :
                      band.type;
      band.node.frequency.value = band.freq;
      band.node.gain.value = band.gain;
      band.node.Q.value = band.Q;
      prevNode.connect(band.node);
      prevNode = band.node;
    });

    prevNode.connect(track.eqOutput);
  }

  function drawEQ() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw frequency grid lines & labels
    ctx.fillStyle = "#666";
    ctx.font = "12px monospace";
    ctx.textAlign = "center";

    const freqs = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
    freqs.forEach(f => {
      const x = freqToX(f);
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.strokeStyle = "#333";
      ctx.stroke();
      ctx.fillText(f >= 1000 ? (f/1000) + "k" : f, x, canvas.height - 4);
    });

    // Draw gain lines
    ctx.strokeStyle = "#333";
    for (let g = GAIN_MIN; g <= GAIN_MAX; g += 6) {
      const y = gainToY(g);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
      ctx.fillText(g + "dB", 30, y - 2);
    }

    if (!selectedTrack) return;

    const eqResponse = new Float32Array(canvas.width);
    for (let i = 0; i < canvas.width; i++) {
      const freq = xToFreq(i);
      let mag = 1;

      selectedTrack.eqBands.forEach(band => {
        if (band.type !== "peaking") return;
        const f0 = band.freq;
        const Q = band.Q;
        const gain = band.gain;

        const bw = f0 / Q;
        const diff = Math.abs(freq - f0);
        const influence = Math.exp(-Math.pow(diff / bw, 2));
        mag *= Math.pow(10, (gain * influence) / 40);
      });

      eqResponse[i] = mag;
    }

    ctx.strokeStyle = "#0f0";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < canvas.width; i++) {
      const magDb = 20 * Math.log10(eqResponse[i]);
      const y = gainToY(magDb);
      if (i === 0) ctx.moveTo(i, y);
      else ctx.lineTo(i, y);
    }
    ctx.stroke();

    ctx.fillStyle = "#0f0";
    selectedTrack.eqBands.forEach((band, i) => {
      const x = freqToX(band.freq);
      const y = gainToY(band.gain);
      ctx.beginPath();
      ctx.arc(x, y, 7, 0, Math.PI * 2);
      ctx.fill();
      if (selectedBand === i) {
        ctx.strokeStyle = "#ff0";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    });
  }

  function getBandAtPos(track, x, y) {
    for (let i = 0; i < track.eqBands.length; i++) {
      const band = track.eqBands[i];
      const bx = freqToX(band.freq);
      const by = gainToY(band.gain);
      if (Math.hypot(bx - x, by - y) < 10) return i;
    }
    return null;
  }

  canvas.addEventListener("mousedown", (e) => {
    if (!selectedTrack) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const bandIdx = getBandAtPos(selectedTrack, x, y);
    if (bandIdx !== null) {
      draggingBand = bandIdx;
      selectedBand = bandIdx;
      updateBandUI();
      drawEQ();
    }
  });

  canvas.addEventListener("mousemove", (e) => {
    if (draggingBand === null) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const freq = Math.min(Math.max(xToFreq(x), FREQ_MIN), FREQ_MAX);
    const gain = Math.min(Math.max(yToGain(y), GAIN_MIN), GAIN_MAX);

    const band = selectedTrack.eqBands[draggingBand];
    band.freq = freq;
    band.gain = gain;

    rebuildEQ(selectedTrack);
    drawEQ();
    updateBandUI();
  });

  window.addEventListener("mouseup", () => {
    draggingBand = null;
  });

  addBandBtn.onclick = () => {
    if (!selectedTrack) return;
    selectedTrack.eqBands.push({
      freq: 1000,
      gain: 0,
      Q: 1,
      type: "peaking",
      node: audioContext.createBiquadFilter()
    });
    rebuildEQ(selectedTrack);
    selectedBand = selectedTrack.eqBands.length - 1;
    updateBandUI();
    drawEQ();
  };

  deleteBandBtn.onclick = () => {
    if (selectedBand === null || !selectedTrack) return;
    selectedTrack.eqBands.splice(selectedBand, 1);
    selectedBand = null;
    rebuildEQ(selectedTrack);
    updateBandUI();
    drawEQ();
  };

  bandTypeSelect.onchange = () => {
    if (selectedBand === null || !selectedTrack) return;
    selectedTrack.eqBands[selectedBand].type = bandTypeSelect.value;
    rebuildEQ(selectedTrack);
    drawEQ();
  };

  function updateBandUI() {
    if (selectedBand === null || !selectedTrack) {
      addBandBtn.disabled = false;
      deleteBandBtn.disabled = true;
      bandTypeSelect.disabled = true;
      return;
    }
    addBandBtn.disabled = false;
    deleteBandBtn.disabled = false;
    bandTypeSelect.disabled = false;
    const band = selectedTrack.eqBands[selectedBand];
    bandTypeSelect.value = band.type;
  }

  playBtn.onclick = () => {
    if (!selectedTrack) return;
    selectedTrack.play();
    playBtn.disabled = true;
    stopBtn.disabled = false;
  };

  stopBtn.onclick = () => {
    if (!selectedTrack) return;
    selectedTrack.stop();
    playBtn.disabled = false;
    stopBtn.disabled = true;
  };

  // Dynamics nodes creation (mostly bypass for now)
  function createBypassNode() {
    return audioContext.createGain();
  }
  function createCompressorNode() {
    return audioContext.createDynamicsCompressor();
  }
  function createGateNode() {
    return audioContext.createGain();
  }
  function createDeEsserNode() {
    return audioContext.createGain();
  }
  function createExpanderNode() {
    return audioContext.createGain();
  }
  function createLimiterNode() {
    return audioContext.createGain();
  }

  function createDynNode(type) {
    switch(type) {
      case "compressor": return createCompressorNode();
      case "gate": return createGateNode();
      case "deesser": return createDeEsserNode();
      case "expander": return createExpanderNode();
      case "limiter": return createLimiterNode();
      case "bypass":
      default:
        return createBypassNode();
    }
  }

  function renderDynControls(track, dynIdx) {
    const dyn = track.dynamics[dynIdx];
    const container = dynBoxes[dynIdx].querySelector(".dyn-params");
    container.innerHTML = "";

    const createSlider = (label, min, max, step, value, unit, onChange) => {
      const wrapper = document.createElement("div");

      const lbl = document.createElement("label");
      lbl.textContent = `${label}: `;

      const valSpan = document.createElement("span");
      valSpan.textContent = value + (unit || "");
      valSpan.style.marginLeft = "6px";

      const input = document.createElement("input");
      input.type = "range";
      input.min = min;
      input.max = max;
      input.step = step;
      input.value = value;
      input.style.verticalAlign = "middle";

      input.oninput = () => {
        const val = input.value;
        valSpan.textContent = val + (unit || "");
        onChange(parseFloat(val));
      };

      wrapper.appendChild(lbl);
      wrapper.appendChild(input);
      wrapper.appendChild(valSpan);

      return wrapper;
    };

    if (dyn.type === "compressor") {
      container.appendChild(createSlider("Threshold (dB)", -100, 0, 1, dyn.threshold ?? -24, " dB", v => {
        dyn.threshold = v;
        if (dyn.node.threshold) dyn.node.threshold.value = v;
      }));
      container.appendChild(createSlider("Ratio", 1, 20, 0.1, dyn.ratio ?? 4, "", v => {
        dyn.ratio = v;
        if (dyn.node.ratio) dyn.node.ratio.value = v;
      }));
      container.appendChild(createSlider("Attack (ms)", 0, 1000, 1, dyn.attack ?? 10, " ms", v => {
        dyn.attack = v;
        if (dyn.node.attack) dyn.node.attack.value = v / 1000;
      }));
      container.appendChild(createSlider("Release (ms)", 0, 3000, 1, dyn.release ?? 100, " ms", v => {
        dyn.release = v;
        if (dyn.node.release) dyn.node.release.value = v / 1000;
      }));
      container.appendChild(createSlider("Makeup Gain (dB)", 0, 24, 0.1, dyn.makeup ?? 0, " dB", v => {
        dyn.makeup = v;
        if (dyn.node.makeupGainNode) dyn.node.makeupGainNode.gain.value = Math.pow(10, v / 20);
      }));
    } else if (dyn.type === "gate") {
      container.appendChild(createSlider("Threshold (dB)", -100, 0, 1, dyn.threshold ?? -40, " dB", v => {
        dyn.threshold = v;
      }));
      container.appendChild(createSlider("Attack (ms)", 0, 500, 1, dyn.attack ?? 10, " ms", v => {
        dyn.attack = v;
      }));
      container.appendChild(createSlider("Release (ms)", 0, 1000, 1, dyn.release ?? 100, " ms", v => {
        dyn.release = v;
      }));
      container.appendChild(createSlider("Hold (ms)", 0, 1000, 1, dyn.hold ?? 50, " ms", v => {
        dyn.hold = v;
      }));
    } else {
      container.textContent = "No parameters";
    }
  }

  function updateDynamicsUI() {
    if (!selectedTrack) return;
    dynBoxes.forEach((box, idx) => {
      const dyn = selectedTrack.dynamics[idx];
      const posSelect = box.querySelector(".dyn-position");
      const typeSelect = box.querySelector(".dyn-type");
      posSelect.value = dyn.position;
      typeSelect.value = dyn.type;
      renderDynControls(selectedTrack, idx);
    });
  }

  dynBoxes.forEach((box, idx) => {
    const posSelect = box.querySelector(".dyn-position");
    const typeSelect = box.querySelector(".dyn-type");

    posSelect.onchange = () => {
      if (!selectedTrack) return;
      selectedTrack.dynamics[idx].position = posSelect.value;
      selectedTrack.updateAudioGraph();
    };

    typeSelect.onchange = () => {
      if (!selectedTrack) return;
      const newType = typeSelect.value;
      selectedTrack.dynamics[idx].type = newType;

      selectedTrack.dynamics[idx].node.disconnect();
      selectedTrack.dynamics[idx].node = createDynNode(newType);

      selectedTrack.updateAudioGraph();
      renderDynControls(selectedTrack, idx);
    };
  });

  function setSelectedTrackUI() {
    [...trackListEl.querySelectorAll(".track")].forEach(div => {
      div.classList.toggle("active", div.textContent.includes(selectedTrack.name));
    });
    selectedBand = null;
    updateBandUI();
  }

  loadTracksBtn.onclick = () => {
    loadTracksBtn.disabled = true;
    loadTracks().then(() => {
      loadTracksBtn.disabled = false;
    });
  };

  drawEQ();

  window.addEventListener("keydown", e => {
    if (e.key === "Delete" && !deleteBandBtn.disabled) {
      deleteBandBtn.click();
    }
    if (e.key === "a" && !addBandBtn.disabled) {
      addBandBtn.click();
    }
  });
});
</script>

</body>
</html>
